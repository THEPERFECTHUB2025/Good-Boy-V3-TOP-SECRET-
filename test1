-- ForceHitModule.lua

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

-- Variables
-- ForceHitModule.lua

-- Add Whitelist to the ForceHitModule table
local ForceHitModule = {
    Enabled = false,
    ManuallyEnabled = false,
    AutoTargetAll = false,
    UIMobileSupportEnabled = false,
    WallCheckEnabled = true,
    KillAllEnabled = false,
    AutoStompEnabled = false,
    TargetStrafeEnabled = false,
    BlankShots = true,
    DisableBlankShots = false,
    HitPart = "Head",
    SelectedTarget = nil,
    TargetPlayer = nil,
    Connections = {},
    ForceHitButton = nil,
    ButtonPosition = UDim2.new(0.5, -50, 0.5, -25),
    LastKillAllTime = 0,
    LastTargetSwitchTime = 0,
    StrafeAngle = 0,
    Tracer = nil,
    Attachment0 = nil,
    Attachment1 = nil,
    TargetInfoUI = nil,
    HitSound = nil,
    SavedPosition = nil,
    LastAmmoValue = nil,
    Whitelist = {},
    OriginalEnabledState = nil,
    LastShotTime = 0,
    FiringDelay = 0.1,
    -- Variables pour le FOV
    FOVEnabled = false,
    FOVSize = 120,
    FOVCircle = nil, -- Nouvelle variable pour le cercle FOV
}

-- Initialisation du cercle FOV avec un ScreenGui
local function InitializeFOVCircle()
    -- Si un ancien ScreenGui existe, le détruire
    if ForceHitModule.FOVCircleDrawing then
        ForceHitModule.FOVCircleDrawing.Parent:Destroy()
        ForceHitModule.FOVCircleDrawing = nil
    end

    -- Créer un nouveau ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FOVCircleGui"
    screenGui.IgnoreGuiInset = true
    screenGui.ResetOnSpawn = false -- Empêche la destruction au respawn
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    local frame = Instance.new("Frame")
    frame.Name = "FOVCircle"
    frame.Size = UDim2.new(0, ForceHitModule.FOVSize * 2, 0, ForceHitModule.FOVSize * 2)
    frame.Position = UDim2.new(0.5, -ForceHitModule.FOVSize, 0.5, -ForceHitModule.FOVSize)
    frame.BackgroundColor3 = Color3.fromRGB(0, 255, 255) -- Couleur de fond cyan légère
    frame.BackgroundTransparency = 0.8 -- Fond très transparent
    frame.BorderSizePixel = 0 -- Pas de bordure par défaut
    frame.Visible = ForceHitModule.FOVEnabled -- Restaurer l'état de visibilité

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0) -- Cercle parfait
    corner.Parent = frame

    -- Ajouter un UIStroke pour la bordure avec un effet de gradient tournant
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 4
    stroke.Color = Color3.fromRGB(0, 255, 255)
    stroke.Transparency = 0
    stroke.Parent = frame

    local strokeGradient = Instance.new("UIGradient")
    strokeGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 0, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
    })
    strokeGradient.Rotation = 0
    strokeGradient.Parent = stroke

    -- Ajouter un Frame pour les particules à l'intérieur
    local particleFrame = Instance.new("Frame")
    particleFrame.Size = UDim2.new(1, 0, 1, 0)
    particleFrame.BackgroundTransparency = 1
    particleFrame.Parent = frame

    -- Fonction pour créer une particule bleue
    local function createParticle()
        local particle = Instance.new("Frame")
        particle.Size = UDim2.new(0, 4, 0, 4)
        particle.BackgroundColor3 = Color3.fromRGB(0, 255, 255) -- Bleu cyan
        particle.BackgroundTransparency = 0.4
        particle.Position = UDim2.new(math.random(), 0, math.random(), 0)
        particle.Parent = particleFrame

        local particleCorner = Instance.new("UICorner")
        particleCorner.CornerRadius = UDim.new(1, 0)
        particleCorner.Parent = particle

        local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(particle, tweenInfo, {
            Position = UDim2.new(math.random(), 0, math.random(), 0),
            BackgroundTransparency = 1
        })
        tween:Play()
        tween.Completed:Connect(function()
            particle:Destroy()
        end)
    end

    -- Utiliser RunService.Heartbeat pour gérer les animations
    local lastRotateTime = 0
    local lastFlickerTime = 0
    local lastPulseTime = 0
    local lastParticleTime = 0

    local connection
    connection = RunService.Heartbeat:Connect(function(deltaTime)
        if not frame.Parent or not ForceHitModule.FOVEnabled then
            connection:Disconnect()
            return
        end

        -- Rotation du gradient (toutes les 0.05 secondes)
        local currentTime = tick()
        if currentTime - lastRotateTime >= 0.05 then
            strokeGradient.Rotation = (strokeGradient.Rotation + 360 * deltaTime / 2) % 360
            lastRotateTime = currentTime
        end

        -- Scintillement de la bordure (toutes les 0.6 secondes)
        if currentTime - lastFlickerTime >= 0.6 then
            local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            local tween1 = TweenService:Create(stroke, tweenInfo, {Transparency = 0.2})
            local tween2 = TweenService:Create(stroke, tweenInfo, {Transparency = 0})
            tween1:Play()
            tween1.Completed:Connect(function()
                tween2:Play()
            end)
            lastFlickerTime = currentTime
        end

        -- Effet de pulsation (toutes les 2 secondes)
        if currentTime - lastPulseTime >= 2 then
            local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            local sizeIncrease = ForceHitModule.FOVSize * 2 * 1.05
            local sizeNormal = ForceHitModule.FOVSize * 2
            local tween1 = TweenService:Create(frame, tweenInfo, {Size = UDim2.new(0, sizeIncrease, 0, sizeIncrease)})
            local tween2 = TweenService:Create(frame, tweenInfo, {Size = UDim2.new(0, sizeNormal, 0, sizeNormal)})
            tween1:Play()
            tween1.Completed:Connect(function()
                tween2:Play()
            end)
            lastPulseTime = currentTime
        end

        -- Générer des particules (toutes les 0.3 secondes au lieu de 0.15 pour réduire la charge)
        if currentTime - lastParticleTime >= 0.3 then
            createParticle()
            lastParticleTime = currentTime
        end
    end)

    frame.Parent = screenGui
    ForceHitModule.FOVCircleDrawing = frame
end
-- Appeler la fonction au démarrage pour initialiser le cercle FOV
InitializeFOVCircle()

-- Helper function to check if a player is whitelisted
local function IsPlayerWhitelisted(player)
    if not ForceHitModule.Whitelist then return false end
    for _, whitelistedPlayer in ipairs(ForceHitModule.Whitelist) do
        if whitelistedPlayer == player then
            return true
        end
    end
    return false
end

local function IsTargetInFOV(targetPart)
    if not ForceHitModule.FOVEnabled then return false end

    -- Obtenir la position de la souris
    local mouseLocation = UserInputService:GetMouseLocation()

    -- Obtenir la position de la cible à l'écran
    local screenPosition, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
    if not onScreen then return false end -- La cible n'est pas visible à l'écran

    -- Calculer la distance entre la position de la souris et la position de la cible à l'écran
    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(mouseLocation.X, mouseLocation.Y)).Magnitude

    -- Vérifier si la distance est inférieure au rayon du FOV
    return distance <= ForceHitModule.FOVSize
end

-- Modify GetClosestPlayer to exclude whitelisted players
local function GetClosestPlayerByDistance(minHealth, maxRadius, checkVisibility)
    local ClosestDistance = math.huge
    local ClosestPlayer, ClosestPart, ClosestCharacter = nil, nil, nil
    local LocalCharacter = LocalPlayer.Character
    local LocalPosition = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart") and LocalCharacter.HumanoidRootPart.Position

    if not LocalPosition then return nil, nil, nil end

    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and not IsPlayerWhitelisted(Player) then -- Exclude whitelisted players
            local Character = Player.Character
            if Character and Character:FindFirstChild("Humanoid") and Character.Humanoid.Health > 0 then
                local Part = Character:FindFirstChild(ForceHitModule.HitPart)
                local ForceField = Character:FindFirstChildOfClass("ForceField")
                if Part and not ForceField then
                    local Humanoid = Character:FindFirstChild("Humanoid")
                    if Humanoid and (not minHealth or Humanoid.Health >= minHealth) then
                        local Distance = (LocalPosition - Part.Position).Magnitude
                        if (not maxRadius or Distance <= maxRadius) and Distance < ClosestDistance then
                            if checkVisibility then
                                if not IsTargetBehindWall(LocalPosition, Part.Position) then
                                    ClosestDistance = Distance
                                    ClosestPlayer = Player
                                    ClosestPart = Part
                                    ClosestCharacter = Character
                                end
                            else
                                ClosestDistance = Distance
                                ClosestPlayer = Player
                                ClosestPart = Part
                                ClosestCharacter = Character
                            end
                        end
                    end
                end
            end
        end
    end
    return ClosestPart, ClosestCharacter, ClosestPlayer
end

-- Modify GetClosestPlayerByDistance to exclude whitelisted players
local function GetClosestPlayerByDistance(minHealth, maxRadius, checkVisibility)
    local ClosestDistance = math.huge
    local ClosestPlayer, ClosestPart, ClosestCharacter = nil, nil, nil
    local LocalCharacter = LocalPlayer.Character
    local LocalPosition = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart") and LocalCharacter.HumanoidRootPart.Position

    if not LocalPosition then return nil, nil, nil end

    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and not IsPlayerWhitelisted(Player) then -- Exclude whitelisted players
            local Character = Player.Character
            if Character and Character:FindFirstChild("Humanoid") and Character.Humanoid.Health > 0 then
                local Part = Character:FindFirstChild(ForceHitModule.HitPart)
                local ForceField = Character:FindFirstChildOfClass("ForceField")
                if Part and not ForceField then
                    local Humanoid = Character:FindFirstChild("Humanoid")
                    if Humanoid and (not minHealth or Humanoid.Health >= minHealth) then
                        local Distance = (LocalPosition - Part.Position).Magnitude
                        if (not maxRadius or Distance <= maxRadius) and Distance < ClosestDistance then
                            if checkVisibility then
                                if not IsTargetBehindWall(LocalPosition, Part.Position) then
                                    ClosestDistance = Distance
                                    ClosestPlayer = Player
                                    ClosestPart = Part
                                    ClosestCharacter = Character
                                end
                            else
                                ClosestDistance = Distance
                                ClosestPlayer = Player
                                ClosestPart = Part
                                ClosestCharacter = Character
                            end
                        end
                    end
                end
            end
        end
    end
    return ClosestPart, ClosestCharacter, ClosestPlayer
end

-- Modify UpdateTargetAndHighlight to respect the whitelist
local function UpdateTargetAndHighlight()
    if not ForceHitModule.ManuallyEnabled then
        ForceHitModule.Enabled = false
        if ForceHitModule.Highlight then
            ForceHitModule.Highlight.Enabled = false
        end
        ForceHitModule.SelectedTarget = nil
        ForceHitModule.TargetPlayer = nil
        UpdateTracer()
        ForceHitModule:UpdateTargetInfoUI()
        UpdateFOVCircle() -- Ajout ici
        return
    end

    if ForceHitModule.TargetPlayer then
        if IsPlayerWhitelisted(ForceHitModule.TargetPlayer) then
            ForceHitModule.TargetPlayer = nil
            ForceHitModule.SelectedTarget = nil
        end

        local character = ForceHitModule.TargetPlayer and ForceHitModule.TargetPlayer.Character
        if character then
            local hitPart = character:FindFirstChild(ForceHitModule.HitPart)
            local humanoid = character:FindFirstChild("Humanoid")
            local forceField = character:FindFirstChildOfClass("ForceField")
            if hitPart and humanoid and humanoid.Health > 0 and not forceField then
                ForceHitModule.SelectedTarget = hitPart
                local health = humanoid.Health
                if health <= 15 then
                    ForceHitModule.TargetPlayer = nil
                    ForceHitModule.SelectedTarget = nil
                    if ForceHitModule.Enabled then
                        ForceHitModule.Enabled = false
                    end
                elseif health > 15 then
                    if ForceHitModule.FOVEnabled then
                        if not IsTargetInFOV(hitPart) then
                            ForceHitModule.TargetPlayer = nil
                            ForceHitModule.SelectedTarget = nil
                            if ForceHitModule.Enabled then
                                ForceHitModule.Enabled = false
                            end
                            return
                        end
                    end
                    if not ForceHitModule.Enabled then
                        ForceHitModule.Enabled = true
                    end
                end

                if ForceHitModule.AutoTargetAll then
                    local currentTime = os.clock()
                    if currentTime - ForceHitModule.LastTargetSwitchTime >= 0.5 then
                        ForceHitModule.LastTargetSwitchTime = currentTime
                        local maxRadius = 714.2
                        local newPart, newCharacter, newPlayer = GetClosestPlayerByDistance(15, maxRadius, true)
                        if newPlayer and newPlayer ~= ForceHitModule.TargetPlayer then
                            ForceHitModule.TargetPlayer = newPlayer
                            ForceHitModule.SelectedTarget = newPart
                        end
                    end
                end

                local localCharacter = LocalPlayer.Character
                local localPosition = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and localCharacter.HumanoidRootPart.Position
                if localPosition and hitPart then
                    local distance = (localPosition - hitPart.Position).Magnitude
                    if ForceHitModule.DisableBlankShots then
                        if distance <= 200 then
                            ForceHitModule.BlankShots = true
                        else
                            ForceHitModule.BlankShots = false
                        end
                    end

                    local targetPosition = hitPart.Position
                    if ForceHitModule.WallCheckEnabled and IsTargetBehindWall(localPosition, targetPosition) then
                        if ForceHitModule.Enabled then
                            ForceHitModule.Enabled = false
                        end
                    else
                        if not ForceHitModule.Enabled and health > 15 then
                            ForceHitModule.Enabled = true
                        end
                    end
                end
            else
                ForceHitModule.SelectedTarget = nil
                ForceHitModule.TargetPlayer = nil
            end
        else
            ForceHitModule.SelectedTarget = nil
            ForceHitModule.TargetPlayer = nil
        end
    end

    if not ForceHitModule.TargetPlayer and ForceHitModule.FOVEnabled then
        local ClosestPart, ClosestCharacter, ClosestPlayer = GetClosestPlayer()
        if ClosestPlayer then
            local humanoid = ClosestCharacter and ClosestCharacter:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 15 then
                if ForceHitModule.FOVEnabled then
                    if not IsTargetInFOV(ClosestPart) then
                        return
                    end
                end
                ForceHitModule.SelectedTarget = ClosestPart
                ForceHitModule.TargetPlayer = ClosestPlayer
                MonitorTargetRespawn()
            end
        end
    end

    if not ForceHitModule.Enabled then
        if ForceHitModule.Highlight then
            ForceHitModule.Highlight.Enabled = false
        end
    end

    local target, character = ForceHitModule.SelectedTarget, nil
    if target and target.Parent then
        character = target.Parent
    end
    if character and ForceHitModule.Highlight then
        ForceHitModule.Highlight.Adornee = character
        ForceHitModule.Highlight.Enabled = true
    else
        if ForceHitModule.Highlight then
            ForceHitModule.Highlight.Enabled = false
        end
    end

    UpdateTracer()
    ForceHitModule:UpdateTargetInfoUI()
end
-- Monitor the target's respawn and update SelectedTarget
local function MonitorTargetRespawn()
    if not ForceHitModule.TargetPlayer then return end

    local player = ForceHitModule.TargetPlayer
    if ForceHitModule.Connections["TargetRespawnMonitor"] then
        ForceHitModule.Connections["TargetRespawnMonitor"]:Disconnect()
    end

    ForceHitModule.Connections["TargetRespawnMonitor"] = player.CharacterAdded:Connect(function(newCharacter)
        if not ForceHitModule.ManuallyEnabled or ForceHitModule.TargetPlayer ~= player then return end

        local hitPart = newCharacter:WaitForChild(ForceHitModule.HitPart, 5)
        local humanoid = newCharacter:WaitForChild("Humanoid", 5)
        local forceField = newCharacter:FindFirstChildOfClass("ForceField")

        if hitPart and humanoid and humanoid.Health > 0 and not forceField then
            ForceHitModule.SelectedTarget = hitPart
        end
    end)
end
-- Modify KillAll to exclude whitelisted players (already handled by GetClosestPlayerByDistance)

-- Modify TargetStrafe to exclude whitelisted players
ForceHitModule.Connections["TargetStrafe"] = RunService.Heartbeat:Connect(function(deltaTime)
    if not ForceHitModule.TargetStrafeEnabled or not ForceHitModule.Enabled or not ForceHitModule.TargetPlayer then
        return
    end

    local currentTime = os.clock()
    if currentTime - (ForceHitModule.LastStrafeTime or 0) < 0.05 then return end -- Mise à jour toutes les 0.05 secondes
    ForceHitModule.LastStrafeTime = currentTime

    if IsPlayerWhitelisted(ForceHitModule.TargetPlayer) then
        ForceHitModule.TargetStrafeEnabled = false
        ForceHitModule.TargetPlayer = nil
        ForceHitModule.SelectedTarget = nil
        return
    end

    local targetCharacter = ForceHitModule.TargetPlayer.Character
    if not targetCharacter then
        ForceHitModule.TargetStrafeEnabled = false
        ForceHitModule.TargetPlayer = nil
        ForceHitModule.SelectedTarget = nil
        return
    end

    local humanoid = targetCharacter:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        ForceHitModule.TargetStrafeEnabled = false
        ForceHitModule.TargetPlayer = nil
        ForceHitModule.SelectedTarget = nil
        return
    end

    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")

    if not localRootPart or not targetRootPart then
        return
    end

    local distance = (localRootPart.Position - targetRootPart.Position).Magnitude
    if distance > 100000 then
        return
    end

    local radius = 5
    local speed = 5

    ForceHitModule.StrafeAngle = ForceHitModule.StrafeAngle + (speed * deltaTime)
    if ForceHitModule.StrafeAngle > 2 * math.pi then
        ForceHitModule.StrafeAngle = ForceHitModule.StrafeAngle - 2 * math.pi
    end

    local offset = Vector3.new(math.cos(ForceHitModule.StrafeAngle) * radius, 0, math.sin(ForceHitModule.StrafeAngle) * radius)
    local newPosition = targetRootPart.Position + offset
    local newCFrame = CFrame.new(newPosition, targetRootPart.Position)
    local heightDifference = targetRootPart.Position.Y - newPosition.Y
    newCFrame = newCFrame + Vector3.new(0, heightDifference, 0)
    localRootPart.CFrame = newCFrame
end)
-- Modify AutoStomp to exclude whitelisted players
ForceHitModule.Connections["AutoStomp"] = RunService.Stepped:Connect(function(time, step)
    if not ForceHitModule.AutoStompEnabled then return end
    -- Only stomp if the target is not whitelisted
    if ForceHitModule.TargetPlayer and not IsPlayerWhitelisted(ForceHitModule.TargetPlayer) then
        ReplicatedStorage.MainEvent:FireServer("Stomp")
    end
end)

-- Modify BlankShots to exclude whitelisted players
-- Add a firing delay to prevent spamming the server
ForceHitModule.LastShotTime = 0
ForceHitModule.FiringDelay = 0.1 -- Adjust this based on the weapon's fire rate (e.g., 0.1 seconds for most guns)

ForceHitModule.Connections["BlankShots"] = RunService.Heartbeat:Connect(function()
    if not ForceHitModule.DisableBlankShots then return end
    if not ForceHitModule.Enabled or not ForceHitModule.BlankShots then return end

    local currentTime = os.clock()
    if currentTime - ForceHitModule.LastShotTime < ForceHitModule.FiringDelay then return end
    ForceHitModule.LastShotTime = currentTime

    -- Vérifier l'existence de MainEvent
    if not ReplicatedStorage:FindFirstChild("MainEvent") then
        warn("MainEvent not found in ReplicatedStorage - Cannot fire shots")
        return
    end

    -- Vérifier si le joueur a un outil
    local HasTool = false
    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            HasTool = true
            break
        end
    end
    if not HasTool then return end

    local AimPart = ForceHitModule.SelectedTarget
    local AimChar = AimPart and AimPart.Parent
    if not AimChar then return end

    local ForceField = AimChar:FindFirstChildOfClass("ForceField")
    if ForceField then return end

    if AimPart and MainEvent then
        -- Calculer des positions dynamiques
        local shootPosition = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position or Vector3.new(0, 0, 0)
        local targetPosition = AimPart.Position
        local normal = (targetPosition - shootPosition).Unit

        local args = {
            "Shoot",
            {
                {
                    [1] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [2] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [3] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [4] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [5] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    }
                },
                {
                    [1] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [2] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [3] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [4] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [5] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    }
                },
                shootPosition,
                shootPosition,
                workspace:GetServerTimeNow()
            }
        }

        -- Utiliser pcall pour capturer les erreurs
        local success, err = pcall(function()
            MainEvent:FireServer(unpack(args))
        end)
        if not success then
            warn("Error firing shot in BlankShots: " .. tostring(err))
        end
    end
end)
-- Update the Cleanup function to clear the whitelist
function ForceHitModule:Cleanup()
    self:Disable()
    if self.ForceHitButton then
        self.ForceHitButton:Destroy()
        self.ForceHitButton = nil
    end
    if self.TargetInfoUI then
        self.TargetInfoUI.ScreenGui:Destroy()
        self.TargetInfoUI = nil
    end
    for _, connection in pairs(self.Connections) do
        connection:Disconnect()
    end
    self.Connections = {}
    if self.Highlight then
        self.Highlight:Destroy()
        self.Highlight = nil
    end
    if self.Tracer then
        self.Tracer:Destroy()
        self.Tracer = nil
    end
    if self.Attachment0 then
        self.Attachment0:Destroy()
        self.Attachment0 = nil
    end
    if self.Attachment1 then
        self.Attachment1:Destroy()
        self.Attachment1 = nil
    end
    if self.HitSound then
        self.HitSound:Destroy()
        self.HitSound = nil
    end
    if self.FOVCircleDrawing then
        self.FOVCircleDrawing.Parent:Destroy()
        self.FOVCircleDrawing = nil
    end
    self.SavedPosition = nil
    self.OriginalEnabledState = nil
    self.Whitelist = {}
    -- Ne pas réinitialiser FOVEnabled et FOVSize pour préserver l'état du toggle
end
-- Helper function to check if a player is whitelisted
local function IsPlayerWhitelisted(player)
    if not ForceHitModule.Whitelist then return false end
    for _, whitelistedPlayer in ipairs(ForceHitModule.Whitelist) do
        if whitelistedPlayer == player then
            return true
        end
    end
    return false
end
-- The rest of the ForceHitModule.lua remains unchanged

-- Liste des armes
local WeaponsList = {
    "[DoubleBarrel]",
    "[Revolver]",
    "[SMG]",
    "[Shotgun]",
    "[Silencer]",
    "[TacticalShotgun]"
}

-- Default ammo values for each weapon
local DefaultAmmoValues = {
    ["[Revolver]"] = 6,
    ["[DoubleBarrel]"] = 2,
    ["[SMG]"] = 20,
    ["[Shotgun]"] = 2,
    ["[Silencer]"] = 12,
    ["[TacticalShotgun]"] = 5
}

-- Initialize Highlight for the target
local function InitializeHighlight()
    if not ForceHitModule.Highlight or not ForceHitModule.Highlight.Parent then
        local highlight = Instance.new("Highlight")
        highlight.Parent = game.CoreGui
        highlight.FillColor = Color3.fromRGB(0, 255, 0)
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Enabled = false
        ForceHitModule.Highlight = highlight
    end
end

-- Call InitializeHighlight at the start
InitializeHighlight()

-- Création du son pour le hit
local hitSound = Instance.new("Sound")
hitSound.SoundId = "rbxassetid://110168723447153"
hitSound.Volume = 1
hitSound.Parent = LocalPlayer
ForceHitModule.HitSound = hitSound

-- Créer l'UI pour le bouton draggable
function ForceHitModule.CreateForceHitButton()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ForceHitUI"
    screenGui.Parent = game.CoreGui
    screenGui.ResetOnSpawn = false

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 120, 0, 60)
    frame.Position = ForceHitModule.ButtonPosition
    frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Active = true
    frame.Draggable = true
    frame.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 0, 0)
    stroke.Transparency = 0.5
    stroke.Parent = frame

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 1, 0)
    button.BackgroundTransparency = 1
    button.Text = "ForceHit: OFF"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.SourceSansBold
    button.Parent = frame

    local function UpdateButtonText()
        button.Text = "ForceHit: " .. (ForceHitModule.ManuallyEnabled and "ON" or "OFF")
        frame.BackgroundColor3 = ForceHitModule.ManuallyEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(50, 50, 50)
    end

    button.MouseButton1Click:Connect(function()
        if not getgenv().Rake.Settings.Misc.ForceHitEnabled then
            return
        end

        local newValue = ForceHitModule:Toggle()
        UpdateButtonText()
    end)

    local dragging = false
    local dragStart = nil
    local startPos = nil

    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    button.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            if dragging then
                local delta = input.Position - dragStart
                local newPos = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
                frame.Position = newPos
            end
        end
    end)

    button.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            ForceHitModule.ButtonPosition = frame.Position
        end
    end)

    UpdateButtonText()
    ForceHitModule.ForceHitButton = screenGui
end

-- Créer l'UI pour les informations sur la cible
-- Créer l'UI pour les informations sur la cible
local function CreateTargetInfoUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "TargetInfoUI"
    screenGui.Parent = game.CoreGui
    screenGui.ResetOnSpawn = false

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 180)
    frame.Position = UDim2.new(0, 10, 0.5, -90)
    frame.BackgroundColor3 = Color3.fromRGB(5, 5, 15)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 0
    frame.Parent = screenGui

    local function adjustPositionForScreen()
        local viewportSize = Camera.ViewportSize
        if viewportSize.X < 600 then
            frame.Size = UDim2.new(0, 250, 0, 150)
            frame.Position = UDim2.new(0, 5, 0.5, -75)
        else
            frame.Size = UDim2.new(0, 300, 0, 180)
            frame.Position = UDim2.new(0, 10, 0.5, -90)
        end
    end
    adjustPositionForScreen()
    Camera:GetPropertyChangedSignal("ViewportSize"):Connect(adjustPositionForScreen)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame

    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 50, 150)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(150, 0, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 150))
    })
    gradient.Rotation = 45
    gradient.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 4
    stroke.Color = Color3.fromRGB(0, 255, 255)
    stroke.Transparency = 0
    stroke.Parent = frame

    local strokeGradient = Instance.new("UIGradient")
    strokeGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 0, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
    })
    strokeGradient.Rotation = 0
    strokeGradient.Parent = stroke

    local shadow = Instance.new("UIStroke")
    shadow.Thickness = 8
    shadow.Color = Color3.fromRGB(0, 255, 255)
    shadow.Transparency = 0.3
    shadow.Parent = frame

    local particleFrame = Instance.new("Frame")
    particleFrame.Size = UDim2.new(1, 0, 1, 0)
    particleFrame.BackgroundTransparency = 1
    particleFrame.Parent = frame

    local function createParticle()
        local particle = Instance.new("Frame")
        particle.Size = UDim2.new(0, 4, 0, 4)
        particle.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
        particle.BackgroundTransparency = 0.4
        particle.Position = UDim2.new(math.random(), 0, math.random(), 0)
        particle.Parent = particleFrame

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = particle

        local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(particle, tweenInfo, {
            Position = UDim2.new(math.random(), 0, math.random(), 0),
            BackgroundTransparency = 1
        })
        tween:Play()
        tween.Completed:Connect(function()
            particle:Destroy()
        end)
    end

    local waveFrame = Instance.new("Frame")
    waveFrame.Size = UDim2.new(1, 0, 1, 0)
    waveFrame.BackgroundTransparency = 1
    waveFrame.Parent = frame

    local function createWave()
        local wave = Instance.new("Frame")
        wave.Size = UDim2.new(1, 0, 0, 1)
        wave.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
        wave.BackgroundTransparency = 0.7
        wave.Position = UDim2.new(0, 0, 0, 0)
        wave.Parent = waveFrame

        local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
        local tween = TweenService:Create(wave, tweenInfo, {
            Position = UDim2.new(0, 0, 1, 0),
            BackgroundTransparency = 0.9
        })
        tween:Play()
        tween.Completed:Connect(function()
            wave:Destroy()
        end)
    end

    local radialFrame = Instance.new("Frame")
    radialFrame.Size = UDim2.new(1, 0, 1, 0)
    radialFrame.BackgroundTransparency = 1
    radialFrame.Parent = frame

    local function createRadialScan()
        local radial = Instance.new("Frame")
        radial.Size = UDim2.new(0, 0, 0, 0)
        radial.Position = UDim2.new(0, 22, 0, 72)
        radial.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
        radial.BackgroundTransparency = 0.5
        radial.Parent = radialFrame

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = radial

        local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(radial, tweenInfo, {
            Size = UDim2.new(0, 100, 0, 100),
            BackgroundTransparency = 1
        })
        tween:Play()
        tween.Completed:Connect(function()
            radial:Destroy()
        end)
    end

    local connectionFrame = Instance.new("Frame")
    connectionFrame.Size = UDim2.new(1, 0, 1, 0)
    connectionFrame.BackgroundTransparency = 1
    connectionFrame.Parent = frame

    local function createConnectionParticle()
        local particle = Instance.new("Frame")
        particle.Size = UDim2.new(0, 3, 0, 3)
        particle.Position = UDim2.new(0, 35, 0, 75)
        particle.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
        particle.BackgroundTransparency = 0.5
        particle.Parent = connectionFrame

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = particle

        local angle = math.random() * 2 * math.pi
        local endX = 35 + math.cos(angle) * 150
        local endY = 75 + math.sin(angle) * 150

        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(particle, tweenInfo, {
            Position = UDim2.new(0, endX, 0, endY),
            BackgroundTransparency = 1
        })
        tween:Play()
        tween.Completed:Connect(function()
            particle:Destroy()
        end)
    end

    local glitchFrame = Instance.new("Frame")
    glitchFrame.Size = UDim2.new(1, 0, 1, 0)
    glitchFrame.BackgroundTransparency = 1
    glitchFrame.Parent = frame

    local function createGlitchLine()
        local glitchLine = Instance.new("Frame")
        glitchLine.Size = UDim2.new(1, 0, 0, 2)
        glitchLine.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
        glitchLine.BackgroundTransparency = 0.7
        glitchLine.Position = UDim2.new(0, 0, math.random(), 0)
        glitchLine.Parent = glitchFrame

        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
        local tween = TweenService:Create(glitchLine, tweenInfo, {BackgroundTransparency = 1})
        tween:Play()
        tween.Completed:Connect(function()
            glitchLine:Destroy()
        end)
    end

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "Indicator"
    titleLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
    titleLabel.TextScaled = true
    titleLabel.Font = Enum.Font.SciFi
    titleLabel.Parent = frame

    local infoLabel = Instance.new("TextLabel")
    infoLabel.Size = UDim2.new(1, 0, 0, 20)
    infoLabel.Position = UDim2.new(0, 0, 0, 30)
    infoLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 40)
    infoLabel.BackgroundTransparency = 0.5
    infoLabel.Text = "INFO"
    infoLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    infoLabel.TextScaled = true
    infoLabel.Font = Enum.Font.Code
    infoLabel.Parent = frame

    local scanLine = Instance.new("Frame")
    scanLine.Size = UDim2.new(1, 0, 0, 2)
    scanLine.Position = UDim2.new(0, 0, 0, 30)
    scanLine.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
    scanLine.BackgroundTransparency = 0.5
    scanLine.Parent = frame

    local iconFrame = Instance.new("Frame")
    iconFrame.Size = UDim2.new(0, 50, 0, 50)
    iconFrame.Position = UDim2.new(0, 10, 0, 50)
    iconFrame.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
    iconFrame.BackgroundTransparency = 0.6
    iconFrame.Parent = frame

    local iconCorner = Instance.new("UICorner")
    iconCorner.CornerRadius = UDim.new(1, 0)
    iconCorner.Parent = iconFrame

    local icon = Instance.new("ImageLabel")
    icon.Size = UDim2.new(0, 46, 0, 46)
    icon.Position = UDim2.new(0, 2, 0, 2)
    icon.BackgroundTransparency = 1
    icon.Image = "rbxasset://textures/ui/GuiImagePlaceholder.png"
    icon.Parent = iconFrame

    local iconInnerCorner = Instance.new("UICorner")
    iconInnerCorner.CornerRadius = UDim.new(1, 0)
    iconInnerCorner.Parent = icon

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(0, 220, 0, 25)
    nameLabel.Position = UDim2.new(0, 70, 0, 50)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = "No Target"
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextScaled = true
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Font = Enum.Font.Code
    nameLabel.Parent = frame

    local healthLabel = Instance.new("TextLabel")
    healthLabel.Size = UDim2.new(0, 110, 0, 25)
    healthLabel.Position = UDim2.new(0, 70, 0, 75)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "0/0"
    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    healthLabel.TextScaled = true
    healthLabel.TextXAlignment = Enum.TextXAlignment.Left
    healthLabel.Font = Enum.Font.Code
    healthLabel.Parent = frame

    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Size = UDim2.new(0, 100, 0, 25)
    distanceLabel.Position = UDim2.new(0, 190, 0, 75)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "0 studs"
    distanceLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
    distanceLabel.TextScaled = true
    distanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    distanceLabel.Font = Enum.Font.Code
    distanceLabel.Parent = frame

    local weaponLabel = Instance.new("TextLabel")
    weaponLabel.Size = UDim2.new(0, 220, 0, 25)
    weaponLabel.Position = UDim2.new(0, 70, 0, 100)
    weaponLabel.BackgroundTransparency = 1
    weaponLabel.Text = ""
    weaponLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
    weaponLabel.TextScaled = true
    weaponLabel.TextXAlignment = Enum.TextXAlignment.Left
    weaponLabel.Font = Enum.Font.Code
    weaponLabel.Parent = frame

    -- Utiliser RunService.Heartbeat pour gérer toutes les animations
    local lastGradientRotateTime = 0
    local lastStrokeRotateTime = 0
    local lastFlickerTime = 0
    local lastHologramTime = 0
    local lastParticleTime = 0
    local lastWaveTime = 0
    local lastRadialTime = 0
    local lastConnectionTime = 0
    local lastGlitchTime = 0
    local lastShakeTime = 0
    local lastScanLineTime = 0
    local lastIconPulseTime = 0
    local lastTitleGlitchTime = 0
    local lastNameGlitchTime = 0
    local lastHealthGlitchTime = 0
    local lastDistanceGlitchTime = 0
    local lastWeaponGlitchTime = 0

    local connection
    connection = RunService.Heartbeat:Connect(function(deltaTime)
        if not frame.Parent or not frame.Visible then
            connection:Disconnect()
            return
        end

        local currentTime = tick()

        -- Rotation du gradient du fond (toutes les 0.05 secondes)
        if currentTime - lastGradientRotateTime >= 0.05 then
            gradient.Rotation = (gradient.Rotation + 360 * deltaTime / 4) % 360
            lastGradientRotateTime = currentTime
        end

        -- Rotation du gradient de la bordure (toutes les 0.05 secondes)
        if currentTime - lastStrokeRotateTime >= 0.05 then
            strokeGradient.Rotation = (strokeGradient.Rotation + 360 * deltaTime / 2) % 360
            lastStrokeRotateTime = currentTime
        end

        -- Scintillement de la bordure (toutes les 0.6 secondes)
        if currentTime - lastFlickerTime >= 0.6 then
            local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            local tween1 = TweenService:Create(stroke, tweenInfo, {Transparency = 0.2})
            local tween2 = TweenService:Create(stroke, tweenInfo, {Transparency = 0})
            tween1:Play()
            tween1.Completed:Connect(function()
                tween2:Play()
            end)
            lastFlickerTime = currentTime
        end

        -- Effet hologramme (toutes les 2.4 secondes)
        if currentTime - lastHologramTime >= 2.4 then
            local tweenInfo = TweenInfo.new(1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            local tween1 = TweenService:Create(frame, tweenInfo, {BackgroundTransparency = 0.6})
            local tween2 = TweenService:Create(frame, tweenInfo, {BackgroundTransparency = 0.4})
            tween1:Play()
            tween1.Completed:Connect(function()
                tween2:Play()
            end)
            lastHologramTime = currentTime
        end

        -- Particules (toutes les 0.3 secondes au lieu de 0.15)
        if currentTime - lastParticleTime >= 0.3 then
            createParticle()
            lastParticleTime = currentTime
        end

        -- Vagues (toutes les 1.6 secondes au lieu de 0.8)
        if currentTime - lastWaveTime >= 1.6 then
            createWave()
            lastWaveTime = currentTime
        end

        -- Scans radiaux (toutes les 4 secondes au lieu de 2)
        if currentTime - lastRadialTime >= 4 then
            createRadialScan()
            lastRadialTime = currentTime
        end

        -- Particules de connexion (toutes les 0.6 secondes au lieu de 0.3)
        if currentTime - lastConnectionTime >= 0.6 then
            createConnectionParticle()
            lastConnectionTime = currentTime
        end

        -- Lignes de glitch (toutes les 5 secondes au lieu de 1-3)
        if currentTime - lastGlitchTime >= 5 then
            createGlitchLine()
            lastGlitchTime = currentTime
        end

        -- Effet de secousse (toutes les 6 secondes au lieu de 2-4)
        if currentTime - lastShakeTime >= 6 then
            local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
            local offsetX = math.random(-2, 2)
            local offsetY = math.random(-2, 2)
            local tween = TweenService:Create(frame, tweenInfo, {Position = UDim2.new(0, 10 + offsetX, 0.5, -90 + offsetY)})
            tween:Play()
            lastShakeTime = currentTime
        end

        -- Animation de la ligne de scan (toutes les 1.3 secondes)
        if currentTime - lastScanLineTime >= 1.3 then
            scanLine.Position = UDim2.new(0, 0, 0, 30)
            local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
            local tween = TweenService:Create(scanLine, tweenInfo, {Position = UDim2.new(0, 0, 1, -2)})
            tween:Play()
            lastScanLineTime = currentTime
        end

        -- Pulsation de l'icône (toutes les 1.2 secondes)
        if currentTime - lastIconPulseTime >= 1.2 then
            local tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            local tween1 = TweenService:Create(iconFrame, tweenInfo, {BackgroundTransparency = 0.8})
            local tween2 = TweenService:Create(iconFrame, tweenInfo, {BackgroundTransparency = 0.6})
            tween1:Play()
            tween1.Completed:Connect(function()
                tween2:Play()
            end)
            lastIconPulseTime = currentTime
        end

        -- Glitch du titre (toutes les 5 secondes)
        if currentTime - lastTitleGlitchTime >= 5 then
            titleLabel.TextTransparency = 0.2
            titleLabel.Position = UDim2.new(0, math.random(-2, 2), 0, 0)
            task.wait(0.05)
            titleLabel.TextTransparency = 0
            titleLabel.Position = UDim2.new(0, 0, 0, 0)
            task.wait(0.05)
            titleLabel.TextTransparency = 0.3
            titleLabel.Position = UDim2.new(0, math.random(-2, 2), 0, 0)
            task.wait(0.05)
            titleLabel.TextTransparency = 0
            titleLabel.Position = UDim2.new(0, 0, 0, 0)
            lastTitleGlitchTime = currentTime
        end

        -- Glitch du nom (toutes les 6 secondes)
        if currentTime - lastNameGlitchTime >= 6 then
            nameLabel.TextTransparency = 0.2
            nameLabel.Position = UDim2.new(0, 70 + math.random(-1, 1), 0, 50)
            task.wait(0.05)
            nameLabel.TextTransparency = 0
            nameLabel.Position = UDim2.new(0, 70, 0, 50)
            task.wait(0.05)
            nameLabel.TextTransparency = 0.3
            nameLabel.Position = UDim2.new(0, 70 + math.random(-1, 1), 0, 50)
            task.wait(0.05)
            nameLabel.TextTransparency = 0
            nameLabel.Position = UDim2.new(0, 70, 0, 50)
            lastNameGlitchTime = currentTime
        end

        -- Glitch de la santé (toutes les 6 secondes)
        if currentTime - lastHealthGlitchTime >= 6 then
            healthLabel.TextTransparency = 0.2
            healthLabel.Position = UDim2.new(0, 70 + math.random(-1, 1), 0, 75)
            task.wait(0.05)
            healthLabel.TextTransparency = 0
            healthLabel.Position = UDim2.new(0, 70, 0, 75)
            task.wait(0.05)
            healthLabel.TextTransparency = 0.3
            healthLabel.Position = UDim2.new(0, 70 + math.random(-1, 1), 0, 75)
            task.wait(0.05)
            healthLabel.TextTransparency = 0
            healthLabel.Position = UDim2.new(0, 70, 0, 75)
            lastHealthGlitchTime = currentTime
        end

        -- Glitch de la distance (toutes les 6 secondes)
        if currentTime - lastDistanceGlitchTime >= 6 then
            distanceLabel.TextTransparency = 0.2
            distanceLabel.Position = UDim2.new(0, 190 + math.random(-1, 1), 0, 75)
            task.wait(0.05)
            distanceLabel.TextTransparency = 0
            distanceLabel.Position = UDim2.new(0, 190, 0, 75)
            task.wait(0.05)
            distanceLabel.TextTransparency = 0.3
            distanceLabel.Position = UDim2.new(0, 190 + math.random(-1, 1), 0, 75)
            task.wait(0.05)
            distanceLabel.TextTransparency = 0
            distanceLabel.Position = UDim2.new(0, 190, 0, 75)
            lastDistanceGlitchTime = currentTime
        end

        -- Glitch de l'arme (toutes les 6 secondes)
        if currentTime - lastWeaponGlitchTime >= 6 then
            weaponLabel.TextTransparency = 0.2
            weaponLabel.Position = UDim2.new(0, 70 + math.random(-1, 1), 0, 100)
            task.wait(0.05)
            weaponLabel.TextTransparency = 0
            weaponLabel.Position = UDim2.new(0, 70, 0, 100)
            task.wait(0.05)
            weaponLabel.TextTransparency = 0.3
            weaponLabel.Position = UDim2.new(0, 70 + math.random(-1, 1), 0, 100)
            task.wait(0.05)
            weaponLabel.TextTransparency = 0
            weaponLabel.Position = UDim2.new(0, 70, 0, 100)
            lastWeaponGlitchTime = currentTime
        end
    end)

    ForceHitModule.TargetInfoUI = {
        ScreenGui = screenGui,
        Frame = frame,
        Icon = icon,
        NameLabel = nameLabel,
        HealthLabel = healthLabel,
        DistanceLabel = distanceLabel,
        WeaponLabel = weaponLabel
    }

    frame.Visible = false
end

local function GetEquippedWeapon(character)
    if not character then return nil end
    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") then
            for _, weapon in pairs(WeaponsList) do
                if child.Name == weapon then
                    return weapon
                end
            end
        end
    end
    return nil
end

-- Function to get the ammo count for the equipped weapon
local function GetEquippedWeaponAmmo(targetPlayer, equippedWeapon)
    if not targetPlayer or not equippedWeapon then return nil end

    -- Check if the weapon is equipped in the character's hands
    local character = targetPlayer.Character
    local equippedTool = character and character:FindFirstChild(equippedWeapon)
    if equippedTool then
        local script = equippedTool:FindFirstChild("Script")
        local ammo = script and script:FindFirstChild("Ammo")
        if ammo and ammo:IsA("IntValue") then
            return ammo.Value
        end
    end

    -- If not equipped, check in the backpack
    local backpack = targetPlayer:FindFirstChild("Backpack")
    if backpack then
        local weapon = backpack:FindFirstChild(equippedWeapon)
        if weapon then
            local script = weapon:FindFirstChild("Script")
            local ammo = script and script:FindFirstChild("Ammo")
            if ammo and ammo:IsA("IntValue") then
                return ammo.Value
            end
        end
    end

    -- Fallback to default ammo value if not found
    return DefaultAmmoValues[equippedWeapon]
end

function ForceHitModule:UpdateTargetInfoUI()
    if not self.TargetInfoUI then
        CreateTargetInfoUI()
    end

    local ui = self.TargetInfoUI
    if not getgenv().Rake.Settings.Misc.TargetInfoEnabled or not self.ManuallyEnabled or not self.TargetPlayer then
        if ui.Frame.Visible then
            ui.Frame.Visible = true
            local particleFrame = Instance.new("Frame")
            particleFrame.Size = UDim2.new(1, 0, 1, 0)
            particleFrame.BackgroundTransparency = 1
            particleFrame.Parent = ui.Frame

            local function createExplosionParticle()
                local particle = Instance.new("Frame")
                particle.Size = UDim2.new(0, 5, 0, 5)
                particle.Position = UDim2.new(0.5, 0, 0.5, 0)
                particle.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
                particle.BackgroundTransparency = 0.3
                particle.Parent = particleFrame

                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(1, 0)
                corner.Parent = particle

                local angle = math.random() * 2 * math.pi
                local endX = math.cos(angle) * 200
                local endY = math.sin(angle) * 200

                local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                local tween = TweenService:Create(particle, tweenInfo, {
                    Position = UDim2.new(0.5, endX, 0.5, endY),
                    BackgroundTransparency = 1
                })
                tween:Play()
                tween.Completed:Connect(function()
                    particle:Destroy()
                end)
            end

            for i = 1, 5 do -- Réduit de 20 à 5 particules
                createExplosionParticle()
            end

            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local tween = TweenService:Create(ui.Frame, tweenInfo, {BackgroundTransparency = 1, Size = UDim2.new(0, 0, 0, 0)})
            tween:Play()
            tween.Completed:Connect(function()
                ui.Frame.Visible = false
                ui.Frame.BackgroundTransparency = 0.5
                ui.Frame.Size = Camera.ViewportSize.X < 600 and UDim2.new(0, 250, 0, 150) or UDim2.new(0, 300, 0, 180)
                particleFrame:Destroy()
            end)
        end
        return
    end

    local targetPlayer = self.TargetPlayer
    local character = targetPlayer.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    local targetRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

    if not humanoid or not targetRootPart or not localRootPart then
        if ui.Frame.Visible then
            ui.Frame.Visible = true
            local particleFrame = Instance.new("Frame")
            particleFrame.Size = UDim2.new(1, 0, 1, 0)
            particleFrame.BackgroundTransparency = 1
            particleFrame.Parent = ui.Frame

            local function createExplosionParticle()
                local particle = Instance.new("Frame")
                particle.Size = UDim2.new(0, 5, 0, 5)
                particle.Position = UDim2.new(0.5, 0, 0.5, 0)
                particle.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
                particle.BackgroundTransparency = 0.3
                particle.Parent = particleFrame

                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(1, 0)
                corner.Parent = particle

                local angle = math.random() * 2 * math.pi
                local endX = math.cos(angle) * 200
                local endY = math.sin(angle) * 200

                local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                local tween = TweenService:Create(particle, tweenInfo, {
                    Position = UDim2.new(0.5, endX, 0.5, endY),
                    BackgroundTransparency = 1
                })
                tween:Play()
                tween.Completed:Connect(function()
                    particle:Destroy()
                end)
            end

            for i = 1, 5 do -- Réduit de 20 à 5 particules
                createExplosionParticle()
            end

            local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            local tween = TweenService:Create(ui.Frame, tweenInfo, {BackgroundTransparency = 1, Size = UDim2.new(0, 0, 0, 0)})
            tween:Play()
            tween.Completed:Connect(function()
                ui.Frame.Visible = false
                ui.Frame.BackgroundTransparency = 0.5
                ui.Frame.Size = Camera.ViewportSize.X < 600 and UDim2.new(0, 250, 0, 150) or UDim2.new(0, 300, 0, 180)
                particleFrame:Destroy()
            end)
        end
        return
    end

    local userId = targetPlayer.UserId
    ui.Icon.Image = "rbxthumb://type=AvatarHeadShot&id=" .. userId .. "&w=48&h=48"

    ui.NameLabel.Text = targetPlayer.Name .. " (@" .. targetPlayer.DisplayName .. ")"

    local health = math.floor(humanoid.Health)
    local maxHealth = math.floor(humanoid.MaxHealth)
    ui.HealthLabel.Text = health .. "/" .. maxHealth
    if health > maxHealth * 0.5 then
        ui.HealthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    elseif health > maxHealth * 0.25 then
        ui.HealthLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
    else
        ui.HealthLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    end

    local distance = (localRootPart.Position - targetRootPart.Position).Magnitude
    ui.DistanceLabel.Text = math.floor(distance) .. " studs"
    if distance <= 50 then
        ui.DistanceLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    elseif distance <= 100 then
        ui.DistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
    else
        ui.DistanceLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    end

    -- Update weapon and ammo display
    local equippedWeapon = GetEquippedWeapon(character)
    local ammoCount = equippedWeapon and GetEquippedWeaponAmmo(targetPlayer, equippedWeapon) or nil
    if equippedWeapon and ammoCount then
        ui.WeaponLabel.Text = equippedWeapon .. " - Ammo: " .. ammoCount
    else
        ui.WeaponLabel.Text = equippedWeapon or "None"
    end

    if health <= maxHealth * 0.25 and ui.Frame.Visible then
        local pulseSpeed = 0.3
        local tweenInfo = TweenInfo.new(pulseSpeed, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
        local tween1 = TweenService:Create(ui.Frame, tweenInfo, {Size = Camera.ViewportSize.X < 600 and UDim2.new(0, 260, 0, 155) or UDim2.new(0, 310, 0, 185)})
        local tween2 = TweenService:Create(ui.Frame, tweenInfo, {Size = Camera.ViewportSize.X < 600 and UDim2.new(0, 250, 0, 150) or UDim2.new(0, 300, 0, 180)})
        tween1:Play()
        tween1.Completed:Connect(function()
            tween2:Play()
        end)

        local glitchFrame = ui.Frame:FindFirstChild("GlitchFrame") or Instance.new("Frame")
        glitchFrame.Name = "GlitchFrame"
        glitchFrame.Size = UDim2.new(1, 0, 1, 0)
        glitchFrame.BackgroundTransparency = 1
        glitchFrame.Parent = ui.Frame

        local function createIntenseGlitchLine()
            local glitchLine = Instance.new("Frame")
            glitchLine.Size = UDim2.new(1, 0, 0, 2)
            glitchLine.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            glitchLine.BackgroundTransparency = 0.5
            glitchLine.Position = UDim2.new(0, 0, math.random(), 0)
            glitchLine.Parent = glitchFrame

            local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            local tween = TweenService:Create(glitchLine, tweenInfo, {BackgroundTransparency = 1})
            tween:Play()
            tween.Completed:Connect(function()
                glitchLine:Destroy()
            end)
        end

        for i = 1, 3 do
            createIntenseGlitchLine()
        end
    end

    if not ui.Frame.Visible then
        ui.Frame.Visible = true
        ui.Frame.BackgroundTransparency = 1
        ui.Frame.Size = UDim2.new(0, 0, 0, 0)

        local particleFrame = Instance.new("Frame")
        particleFrame.Size = UDim2.new(1, 0, 1, 0)
        particleFrame.BackgroundTransparency = 1
        particleFrame.Parent = ui.Frame

        local function createConvergingParticle()
            local particle = Instance.new("Frame")
            particle.Size = UDim2.new(0, 5, 0, 5)
            local angle = math.random() * 2 * math.pi
            local startX = math.cos(angle) * 200
            local startY = math.sin(angle) * 200
            particle.Position = UDim2.new(0.5, startX, 0.5, startY)
            particle.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
            particle.BackgroundTransparency = 0.3
            particle.Parent = particleFrame

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = particle

            local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
            local tween = TweenService:Create(particle, tweenInfo, {
                Position = UDim2.new(0.5, 0, 0.5, 0),
                BackgroundTransparency = 1
            })
            tween:Play()
            tween.Completed:Connect(function()
                particle:Destroy()
            end)
        end

        for i = 1, 5 do -- Réduit de 20 à 5 particules
            createConvergingParticle()
        end

        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(ui.Frame, tweenInfo, {BackgroundTransparency = 0.5, Size = Camera.ViewportSize.X < 600 and UDim2.new(0, 250, 0, 150) or UDim2.new(0, 300, 0, 180)})
        tween:Play()
        tween.Completed:Connect(function()
            particleFrame:Destroy()
        end)
    end
end

-- New function to continuously monitor the ammo value of the equipped weapon
local function MonitorTargetAmmo()
    local lastAmmoCheckTime = 0
    ForceHitModule.Connections["MonitorAmmo"] = RunService.Heartbeat:Connect(function()
        local currentTime = os.clock()
        if currentTime - lastAmmoCheckTime < 0.5 then return end
        lastAmmoCheckTime = currentTime

        if not ForceHitModule.ManuallyEnabled or not ForceHitModule.TargetPlayer or not ForceHitModule.TargetInfoUI then
            ForceHitModule.LastAmmoValue = nil
            return
        end

        local targetPlayer = ForceHitModule.TargetPlayer
        local character = targetPlayer.Character
        if not character then
            ForceHitModule.LastAmmoValue = nil
            return
        end

        local equippedWeapon = GetEquippedWeapon(character)
        if not equippedWeapon then
            ForceHitModule.LastAmmoValue = nil
            if ForceHitModule.TargetInfoUI.WeaponLabel.Text ~= "None" then
                ForceHitModule.TargetInfoUI.WeaponLabel.Text = "None"
            end
            return
        end

        local currentAmmo = GetEquippedWeaponAmmo(targetPlayer, equippedWeapon)
        if currentAmmo == nil then
            currentAmmo = DefaultAmmoValues[equippedWeapon]
        end

        if ForceHitModule.LastAmmoValue ~= currentAmmo then
            ForceHitModule.LastAmmoValue = currentAmmo
            ForceHitModule.TargetInfoUI.WeaponLabel.Text = equippedWeapon .. " - Ammo: " .. currentAmmo
        end

        local currentWeaponText = equippedWeapon .. " - Ammo: " .. currentAmmo
        if ForceHitModule.TargetInfoUI.WeaponLabel.Text ~= currentWeaponText then
            ForceHitModule.TargetInfoUI.WeaponLabel.Text = currentWeaponText
        end
    end)
end

local function GetClosestPlayer()
    local MouseLocation = UserInputService:GetMouseLocation()
    local ClosestToMouse = math.huge
    local ClosestPlayer, ClosestPart, ClosestCharacter = nil, nil, nil

    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and not IsPlayerWhitelisted(Player) then
            local Character = Player.Character
            if Character and Character:FindFirstChild("Humanoid") and Character.Humanoid.Health > 0 then
                local Part = Character:FindFirstChild(ForceHitModule.HitPart)
                local ForceField = Character:FindFirstChildOfClass("ForceField")
                if Part and not ForceField then
                    local Humanoid = Character:FindFirstChild("Humanoid")
                    if Humanoid and Humanoid.Health > 15 then -- Vérifier que la cible a plus de 15 HP
                        local ScreenPosition, OnScreen = Camera:WorldToViewportPoint(Part.Position)
                        if OnScreen then
                            -- Si FOVEnabled est activé, vérifier si la cible est dans le FOV
                            if ForceHitModule.FOVEnabled then
                                if not IsTargetInFOV(Part) then
                                    -- Simuler un 'continue' en sautant le reste de la boucle
                                    goto skip_player
                                end
                            end

                            local MouseDistance = (Vector2.new(ScreenPosition.X, ScreenPosition.Y) - MouseLocation).Magnitude
                            local Score = MouseDistance

                            if Score < ClosestToMouse then
                                ClosestToMouse = Score
                                ClosestPlayer = Player
                                ClosestPart = Part
                                ClosestCharacter = Character
                            end
                        end
                    end
                end
            end
        end
        ::skip_player:: -- Étiquette pour simuler le 'continue'
    end
    return ClosestPart, ClosestCharacter, ClosestPlayer
end

local function GetClosestPlayerByDistance(minHealth, maxRadius, checkVisibility)
    local ClosestDistance = math.huge
    local ClosestPlayer, ClosestPart, ClosestCharacter = nil, nil, nil
    local LocalCharacter = LocalPlayer.Character
    local LocalPosition = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart") and LocalCharacter.HumanoidRootPart.Position

    if not LocalPosition then return nil, nil, nil end

    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and not IsPlayerWhitelisted(Player) then
            local Character = Player.Character
            if Character and Character:FindFirstChild("Humanoid") and Character.Humanoid.Health > 0 then
                local Part = Character:FindFirstChild(ForceHitModule.HitPart)
                local ForceField = Character:FindFirstChildOfClass("ForceField")
                if Part and not ForceField then
                    local Humanoid = Character:FindFirstChild("Humanoid")
                    if Humanoid and (not minHealth or Humanoid.Health >= minHealth) then
                        local Distance = (LocalPosition - Part.Position).Magnitude
                        if (not maxRadius or Distance <= maxRadius) and Distance < ClosestDistance then
                            if checkVisibility then
                                if not IsTargetBehindWall(LocalPosition, Part.Position) then
                                    ClosestDistance = Distance
                                    ClosestPlayer = Player
                                    ClosestPart = Part
                                    ClosestCharacter = Character
                                end
                            else
                                ClosestDistance = Distance
                                ClosestPlayer = Player
                                ClosestPart = Part
                                ClosestCharacter = Character
                            end
                        end
                    end
                end
            end
        end
    end
    return ClosestPart, ClosestCharacter, ClosestPlayer
end
local function IsTargetBehindWall(localPosition, targetPosition)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, ForceHitModule.TargetPlayer and ForceHitModule.TargetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.IgnoreWater = true

    local direction = (targetPosition - localPosition).Unit * (targetPosition - localPosition).Magnitude
    local raycastResult = workspace:Raycast(localPosition, direction, raycastParams)

    return raycastResult ~= nil
end

local function UpdateTracer()
    if not ForceHitModule.ManuallyEnabled or not ForceHitModule.TargetPlayer then
        if ForceHitModule.Tracer then
            ForceHitModule.Tracer:Destroy()
            ForceHitModule.Tracer = nil
        end
        if ForceHitModule.Attachment0 then
            ForceHitModule.Attachment0:Destroy()
            ForceHitModule.Attachment0 = nil
        end
        if ForceHitModule.Attachment1 then
            ForceHitModule.Attachment1:Destroy()
            ForceHitModule.Attachment1 = nil
        end
        return
    end

    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRootPart then
        if ForceHitModule.Tracer then
            ForceHitModule.Tracer:Destroy()
            ForceHitModule.Tracer = nil
        end
        if ForceHitModule.Attachment0 then
            ForceHitModule.Attachment0:Destroy()
            ForceHitModule.Attachment0 = nil
        end
        if ForceHitModule.Attachment1 then
            ForceHitModule.Attachment1:Destroy()
            ForceHitModule.Attachment1 = nil
        end
        return
    end

    local targetCharacter = ForceHitModule.TargetPlayer.Character
    local targetHitPart = targetCharacter and targetCharacter:FindFirstChild(ForceHitModule.HitPart)
    if not targetHitPart then
        if ForceHitModule.Tracer then
            ForceHitModule.Tracer:Destroy()
            ForceHitModule.Tracer = nil
        end
        if ForceHitModule.Attachment0 then
            ForceHitModule.Attachment0:Destroy()
            ForceHitModule.Attachment0 = nil
        end
        if ForceHitModule.Attachment1 then
            ForceHitModule.Attachment1:Destroy()
            ForceHitModule.Attachment1 = nil
        end
        return
    end

    if not ForceHitModule.Tracer then
        local tracer = Instance.new("Beam")
        tracer.Name = "ForceHitTracer"
        tracer.Parent = workspace
        tracer.Enabled = true
        tracer.Color = ColorSequence.new(Color3.new(1, 0, 0))
        tracer.Transparency = NumberSequence.new(0)
        tracer.Width0 = 0.2
        tracer.Width1 = 0.2
        tracer.LightEmission = 1
        tracer.LightInfluence = 0

        local attachment0 = Instance.new("Attachment")
        attachment0.Parent = localRootPart
        ForceHitModule.Attachment0 = attachment0

        local attachment1 = Instance.new("Attachment")
        attachment1.Parent = targetHitPart
        ForceHitModule.Attachment1 = attachment1

        tracer.Attachment0 = attachment0
        tracer.Attachment1 = attachment1

        ForceHitModule.Tracer = tracer
    end

    if ForceHitModule.Attachment0 and ForceHitModule.Attachment0.Parent ~= localRootPart then
        ForceHitModule.Attachment0:Destroy()
        local newAttachment0 = Instance.new("Attachment")
        newAttachment0.Parent = localRootPart
        ForceHitModule.Attachment0 = newAttachment0
        ForceHitModule.Tracer.Attachment0 = newAttachment0
    end

    if ForceHitModule.Attachment1 and ForceHitModule.Attachment1.Parent ~= targetHitPart then
        ForceHitModule.Attachment1:Destroy()
        local newAttachment1 = Instance.new("Attachment")
        newAttachment1.Parent = targetHitPart
        ForceHitModule.Attachment1 = newAttachment1
        ForceHitModule.Tracer.Attachment1 = newAttachment1
    end
end

local function UpdateTargetAndHighlight()
    if not ForceHitModule.ManuallyEnabled then
        ForceHitModule.Enabled = false
        if ForceHitModule.Highlight then
            ForceHitModule.Highlight.Enabled = false
        end
        ForceHitModule.SelectedTarget = nil
        ForceHitModule.TargetPlayer = nil
        UpdateTracer()
        ForceHitModule:UpdateTargetInfoUI()
        return
    end

    if ForceHitModule.TargetPlayer then
        if IsPlayerWhitelisted(ForceHitModule.TargetPlayer) then
            ForceHitModule.TargetPlayer = nil
            ForceHitModule.SelectedTarget = nil
        end

        local character = ForceHitModule.TargetPlayer and ForceHitModule.TargetPlayer.Character
        if character then
            local hitPart = character:FindFirstChild(ForceHitModule.HitPart)
            local humanoid = character:FindFirstChild("Humanoid")
            local forceField = character:FindFirstChildOfClass("ForceField")
            if hitPart and humanoid and humanoid.Health > 0 and not forceField then
                ForceHitModule.SelectedTarget = hitPart
                local health = humanoid.Health
                if health <= 15 then
                    if ForceHitModule.FOVEnabled then
                        -- Si FOV est activé, réinitialiser la cible et chercher une nouvelle
                        ForceHitModule.TargetPlayer = nil
                        ForceHitModule.SelectedTarget = nil
                        if ForceHitModule.Enabled then
                            ForceHitModule.Enabled = false
                        end
                    else
                        -- Si FOV n'est pas activé, ne pas réinitialiser TargetPlayer, laisser MonitorTargetRespawn gérer la réapparition
                        ForceHitModule.SelectedTarget = nil -- On désactive temporairement SelectedTarget, mais on garde TargetPlayer
                        if ForceHitModule.Enabled then
                            ForceHitModule.Enabled = false -- Désactiver temporairement jusqu'à ce que la cible réapparaisse
                        end
                    end
                elseif health > 15 then
                    if ForceHitModule.FOVEnabled then
                        if not IsTargetInFOV(hitPart) then
                            ForceHitModule.TargetPlayer = nil
                            ForceHitModule.SelectedTarget = nil
                            if ForceHitModule.Enabled then
                                ForceHitModule.Enabled = false
                            end
                            return
                        end
                    end
                    if not ForceHitModule.Enabled then
                        ForceHitModule.Enabled = true
                    end
                end

                if ForceHitModule.AutoTargetAll then
                    local currentTime = os.clock()
                    if currentTime - ForceHitModule.LastTargetSwitchTime >= 0.5 then
                        ForceHitModule.LastTargetSwitchTime = currentTime
                        local maxRadius = 714.2
                        local newPart, newCharacter, newPlayer = GetClosestPlayerByDistance(15, maxRadius, true)
                        if newPlayer and newPlayer ~= ForceHitModule.TargetPlayer then
                            ForceHitModule.TargetPlayer = newPlayer
                            ForceHitModule.SelectedTarget = newPart
                        end
                    end
                end

                local localCharacter = LocalPlayer.Character
                local localPosition = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and localCharacter.HumanoidRootPart.Position
                if localPosition and hitPart then
                    local distance = (localPosition - hitPart.Position).Magnitude
                    if ForceHitModule.DisableBlankShots then
                        if distance <= 200 then
                            ForceHitModule.BlankShots = true
                        else
                            ForceHitModule.BlankShots = false
                        end
                    end

                    local targetPosition = hitPart.Position
                    if ForceHitModule.WallCheckEnabled and IsTargetBehindWall(localPosition, targetPosition) then
                        if ForceHitModule.Enabled then
                            ForceHitModule.Enabled = false
                        end
                    else
                        if not ForceHitModule.Enabled and health > 15 then
                            ForceHitModule.Enabled = true
                        end
                    end
                end
            else
                -- Cible invalide (morte ou sans character), mais on garde TargetPlayer si FOVEnabled est désactivé
                if ForceHitModule.FOVEnabled then
                    ForceHitModule.SelectedTarget = nil
                    ForceHitModule.TargetPlayer = nil
                else
                    ForceHitModule.SelectedTarget = nil -- On désactive temporairement SelectedTarget
                    if ForceHitModule.Enabled then
                        ForceHitModule.Enabled = false -- Désactiver temporairement jusqu'à réapparition
                    end
                end
            end
        else
            -- Pas de character, mais on garde TargetPlayer si FOVEnabled est désactivé
            if ForceHitModule.FOVEnabled then
                ForceHitModule.SelectedTarget = nil
                ForceHitModule.TargetPlayer = nil
            else
                ForceHitModule.SelectedTarget = nil
                if ForceHitModule.Enabled then
                    ForceHitModule.Enabled = false -- Désactiver temporairement jusqu'à réapparition
                end
            end
        end
    end

    -- Si aucune cible et FOVEnabled est activé, chercher une nouvelle cible
    if not ForceHitModule.TargetPlayer and ForceHitModule.FOVEnabled then
        local ClosestPart, ClosestCharacter, ClosestPlayer = GetClosestPlayer()
        if ClosestPlayer then
            local humanoid = ClosestCharacter and ClosestCharacter:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 15 then
                if ForceHitModule.FOVEnabled then
                    if not IsTargetInFOV(ClosestPart) then
                        return
                    end
                end
                ForceHitModule.SelectedTarget = ClosestPart
                ForceHitModule.TargetPlayer = ClosestPlayer
                MonitorTargetRespawn()
            end
        end
    end

    if not ForceHitModule.Enabled then
        if ForceHitModule.Highlight then
            ForceHitModule.Highlight.Enabled = false
        end
    end

    local target, character = ForceHitModule.SelectedTarget, nil
    if target and target.Parent then
        character = target.Parent
    end
    if character and ForceHitModule.Highlight then
        ForceHitModule.Highlight.Adornee = character
        ForceHitModule.Highlight.Enabled = true
    else
        if ForceHitModule.Highlight then
            ForceHitModule.Highlight.Enabled = false
        end
    end

    UpdateTracer()
    ForceHitModule:UpdateTargetInfoUI()
end

local function UpdateFOVCircle()
    if not ForceHitModule.FOVCircleDrawing then
        InitializeFOVCircle()
        if not ForceHitModule.FOVCircleDrawing then
            return
        end
    end


    if ForceHitModule.FOVEnabled then
        ForceHitModule.FOVCircleDrawing.Visible = true
        ForceHitModule.FOVCircleDrawing.Size = UDim2.new(0, ForceHitModule.FOVSize * 2, 0, ForceHitModule.FOVSize * 2)
    else
        ForceHitModule.FOVCircleDrawing.Visible = false
    end
end
-- Connexion pour gérer la visibilité et la taille (réduite à Heartbeat avec temporisation)
if ForceHitModule.Connections["UpdateFOVCircle"] then
    ForceHitModule.Connections["UpdateFOVCircle"]:Disconnect()
    ForceHitModule.Connections["UpdateFOVCircle"] = nil
end

local lastFOVUpdate = 0
local FOV_UPDATE_INTERVAL = 0.5 -- Mise à jour toutes les 0.5 secondes
ForceHitModule.Connections["UpdateFOVCircle"] = RunService.Heartbeat:Connect(function()
    local currentTime = tick()
    if currentTime - lastFOVUpdate < FOV_UPDATE_INTERVAL then
        return
    end
    lastFOVUpdate = currentTime

    UpdateFOVCircle()
end)
-- Connexion pour gérer le respawn du joueur local
if ForceHitModule.Connections["LocalPlayerRespawn"] then
    ForceHitModule.Connections["LocalPlayerRespawn"]:Disconnect()
    ForceHitModule.Connections["LocalPlayerRespawn"] = nil
end

ForceHitModule.Connections["LocalPlayerRespawn"] = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    newCharacter:WaitForChild("HumanoidRootPart", 5)
    
    InitializeFOVCircle()
    
    UpdateFOVCircle()
    
    if ForceHitModule.FOVEnabled and ForceHitModule.FOVCircleDrawing then
        ForceHitModule.FOVCircleDrawing.Visible = true
    else
    end
end)

-- Nouvelle connexion pour détecter les mouvements de la souris (avec temporisation)
if ForceHitModule.Connections["MouseMoveUpdateFOV"] then
    ForceHitModule.Connections["MouseMoveUpdateFOV"]:Disconnect()
    ForceHitModule.Connections["MouseMoveUpdateFOV"] = nil
end

local lastMouseUpdate = 0
local MOUSE_UPDATE_INTERVAL = 0.1 -- Mise à jour toutes les 0.1 secondes
ForceHitModule.Connections["MouseMoveUpdateFOV"] = UserInputService.InputChanged:Connect(function(input)
    if not ForceHitModule.FOVEnabled or not ForceHitModule.FOVCircleDrawing then
        return
    end

    if input.UserInputType == Enum.UserInputType.MouseMovement then
        local currentTime = tick()
        if currentTime - lastMouseUpdate < MOUSE_UPDATE_INTERVAL then
            return
        end
        lastMouseUpdate = currentTime

        local mouseLocation = UserInputService:GetMouseLocation()
        ForceHitModule.FOVCircleDrawing.Position = UDim2.new(0, mouseLocation.X - ForceHitModule.FOVSize, 0, mouseLocation.Y - ForceHitModule.FOVSize)
    end
end)

  ForceHitModule.Connections["KillAll"] = RunService.Heartbeat:Connect(function()
    if not ForceHitModule.KillAllEnabled then return end

    local currentTime = os.clock()
    if currentTime - ForceHitModule.LastKillAllTime < 0.5 then return end
    ForceHitModule.LastKillAllTime = currentTime

    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRootPart then return end

    -- Vérifier si la cible actuelle est valide et a suffisamment d'HP
    if ForceHitModule.TargetPlayer then
        local targetCharacter = ForceHitModule.TargetPlayer.Character
        local targetHumanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
        if targetHumanoid then
            if targetHumanoid.Health <= 15 or targetHumanoid.Health <= 0 then
                ForceHitModule.TargetPlayer = nil
                ForceHitModule.SelectedTarget = nil
            end
        else
            ForceHitModule.TargetPlayer = nil
            ForceHitModule.SelectedTarget = nil
        end
    end

    -- Si nous n'avons pas de cible, en trouver une nouvelle
    if not ForceHitModule.TargetPlayer then
        local maxRadius = 1785.5
        local closestPart, closestCharacter, closestPlayer = GetClosestPlayerByDistance(15, maxRadius, false)
        if not closestPlayer then return end
        ForceHitModule.TargetPlayer = closestPlayer
        ForceHitModule.SelectedTarget = closestPart
        MonitorTargetRespawn()
    end

    local targetCharacter = ForceHitModule.TargetPlayer.Character
    local targetRootPart = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then return end

    if localRootPart and targetRootPart then
        local success, err = pcall(function()
            localRootPart.CFrame = targetRootPart.CFrame * CFrame.new(0, 0, -2)
        end)
        if not success then
            warn("Error setting CFrame in KillAll: " .. tostring(err))
        end
        ForceHitModule.ManuallyEnabled = true
        ForceHitModule.Enabled = true
    end
end)

ForceHitModule.Connections["TargetStrafe"] = RunService.Heartbeat:Connect(function(deltaTime)
    if not ForceHitModule.TargetStrafeEnabled or not ForceHitModule.Enabled or not ForceHitModule.TargetPlayer then
        return
    end

    if IsPlayerWhitelisted(ForceHitModule.TargetPlayer) then
        ForceHitModule.TargetStrafeEnabled = false
        ForceHitModule.TargetPlayer = nil
        ForceHitModule.SelectedTarget = nil
        return
    end

    local targetCharacter = ForceHitModule.TargetPlayer.Character
    if not targetCharacter then
        ForceHitModule.TargetStrafeEnabled = false
        ForceHitModule.TargetPlayer = nil
        ForceHitModule.SelectedTarget = nil
        return
    end

    local humanoid = targetCharacter:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        ForceHitModule.TargetStrafeEnabled = false
        ForceHitModule.TargetPlayer = nil
        ForceHitModule.SelectedTarget = nil
        return
    end

    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")

    if not localRootPart or not targetRootPart then
        return
    end

    local distance = (localRootPart.Position - targetRootPart.Position).Magnitude
    if distance > 100000 then
        return
    end

    local radius = 5
    local speed = 5

    ForceHitModule.StrafeAngle = ForceHitModule.StrafeAngle + (speed * deltaTime)
    if ForceHitModule.StrafeAngle > 2 * math.pi then
        ForceHitModule.StrafeAngle = ForceHitModule.StrafeAngle - 2 * math.pi
    end

    local offset = Vector3.new(math.cos(ForceHitModule.StrafeAngle) * radius, 0, math.sin(ForceHitModule.StrafeAngle) * radius)
    local newPosition = targetRootPart.Position + offset
    local newCFrame = CFrame.new(newPosition, targetRootPart.Position)
    local heightDifference = targetRootPart.Position.Y - newPosition.Y
    newCFrame = newCFrame + Vector3.new(0, heightDifference, 0)

    local success, err = pcall(function()
        localRootPart.CFrame = newCFrame
    end)
    if not success then
        warn("Error setting CFrame in TargetStrafe: " .. tostring(err))
    end
end)

ForceHitModule.Connections["AutoStomp"] = RunService.Stepped:Connect(function(time, step)
    if not ForceHitModule.AutoStompEnabled then return end
    ReplicatedStorage.MainEvent:FireServer("Stomp")
end)

ForceHitModule.Connections["UpdateTargetAndHighlight"] = RunService.RenderStepped:Connect(UpdateTargetAndHighlight)
-- ... (le début de votre script, avec les variables, InitializeFOVCircle, etc.)

-- Définir l'ID du jeu Hood Customs
local HOOD_CUSTOMS_PLACE_ID = 9825515356

-- Variable pour stocker le hook (sera nil si pas dans Hood Customs)
local OriginalNameCall

-- Vérifier si le joueur est dans Hood Customs
local function IsInHoodCustoms()
    return game.PlaceId == HOOD_CUSTOMS_PLACE_ID
end

-- Appliquer le hook uniquement si le joueur est dans Hood Customs
if IsInHoodCustoms() then
    OriginalNameCall = hookmetamethod(game, "__namecall", function(Object, ...)
        local Arguments = {...}
        local NameCallMethod = getnamecallmethod()

        if not ForceHitModule.Enabled then
            return OriginalNameCall(Object, ...)
        end

        if NameCallMethod == "InvokeServer" and Object.Name == "MainFunction" and #Arguments > 0 and Arguments[1] == "GunCheck" then
            return nil
        end

        if NameCallMethod == "FireServer" and Object.Name == "MainEvent" and #Arguments > 0 and Arguments[1] == "Shoot" then
            local AimPart = ForceHitModule.SelectedTarget
            if AimPart then
                if Arguments[2] and #Arguments[2] > 0 then
                    for _, Table in pairs(Arguments[2][1]) do
                        Table["Instance"] = AimPart
                    end
                    for _, Table in pairs(Arguments[2][2]) do
                        Table["thePart"] = AimPart
                        Table["theOffset"] = CFrame.new()
                    end
                end
                return OriginalNameCall(Object, unpack(Arguments))
            end
        end

        return OriginalNameCall(Object, ...)
    end)
else
    OriginalNameCall = nil
end

-- Boucle BlankShots corrigée
ForceHitModule.Connections["BlankShots"] = RunService.Heartbeat:Connect(function()
    if not ForceHitModule.DisableBlankShots then return end
    if not ForceHitModule.Enabled or not ForceHitModule.BlankShots then return end

    local currentTime = os.clock()
    if currentTime - ForceHitModule.LastShotTime < ForceHitModule.FiringDelay then return end
    ForceHitModule.LastShotTime = currentTime
    local HasTool = false
    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            HasTool = true
            break
        end
    end
    if not HasTool then return end

    local AimPart = ForceHitModule.SelectedTarget
    local AimChar = AimPart and AimPart.Parent
    if not AimChar then return end

    local ForceField = AimChar:FindFirstChildOfClass("ForceField")
    if ForceField then return end

    if AimPart and MainEvent then
        local shootPosition = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position or Vector3.new(0, 0, 0)
        local targetPosition = AimPart.Position
        local normal = (targetPosition - shootPosition).Unit

        local args = {
            "Shoot",
            {
                {
                    [1] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [2] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [3] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [4] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    },
                    [5] = {
                        ["Instance"] = AimPart,
                        ["Normal"] = normal,
                        ["Position"] = targetPosition
                    }
                },
                {
                    [1] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [2] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [3] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [4] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    },
                    [5] = {
                        ["thePart"] = AimPart,
                        ["theOffset"] = CFrame.new(0, 0, 0)
                    }
                },
                shootPosition,
                shootPosition,
                workspace:GetServerTimeNow()
            }
        }

        local success, err = pcall(function()
            MainEvent:FireServer(unpack(args))
        end)
        if not success then
            warn("Error firing shot in BlankShots: " .. tostring(err))
        end
    end
end)
local lastHealth = nil
ForceHitModule.Connections["HitSound"] = RunService.Heartbeat:Connect(function()
    if not ForceHitModule.Enabled or not ForceHitModule.TargetPlayer then
        lastHealth = nil
        return
    end

    local targetChar = ForceHitModule.TargetPlayer and ForceHitModule.TargetPlayer.Character
    if not (targetChar and targetChar:FindFirstChild("Humanoid")) then
        lastHealth = nil
        return
    end

    local humanoid = targetChar.Humanoid
    local currentHealth = humanoid.Health

    if lastHealth == nil then
        lastHealth = currentHealth
        return
    end

    if currentHealth < lastHealth and currentHealth > 0 then
        ForceHitModule.HitSound:Play()
    end

    lastHealth = currentHealth
end)

ForceHitModule.Connections["CameraDestroyerMonitor"] = RunService.Heartbeat:Connect(function()
    if getgenv().DC then
        -- Camera Destroyer is active
        if ForceHitModule.OriginalEnabledState == nil then
            -- Store the original state of Enabled if not already stored
            ForceHitModule.OriginalEnabledState = ForceHitModule.Enabled
        end
        ForceHitModule.Enabled = false -- Disable ForceHit while Camera Destroyer is active
    else
        -- Camera Destroyer is inactive
        if ForceHitModule.OriginalEnabledState ~= nil then
            -- Restore the original state of Enabled
            ForceHitModule.Enabled = ForceHitModule.OriginalEnabledState
            ForceHitModule.OriginalEnabledState = nil -- Clear the stored state
        end
    end
end)

function ForceHitModule:Enable()
    if self.ManuallyEnabled then return end
    self.ManuallyEnabled = true
    self.Enabled = true
    if not self.TargetPlayer then
        local ClosestPart, ClosestCharacter, ClosestPlayer = GetClosestPlayer()
        self.SelectedTarget = ClosestPart
        self.TargetPlayer = ClosestPlayer
        MonitorTargetRespawn() -- Add this to monitor the target's respawn
    end
    -- Start monitoring ammo when enabling
    MonitorTargetAmmo()
    -- Force an immediate update to ensure visuals appear
    UpdateTargetAndHighlight()
end
function ForceHitModule:Disable()
    if not self.ManuallyEnabled then return end
    self.ManuallyEnabled = false
    self.Enabled = false
    self.SelectedTarget = nil
    self.TargetPlayer = nil
    if self.Highlight then
        self.Highlight.Enabled = false
    end
    if self.Tracer then
        self.Tracer:Destroy()
        self.Tracer = nil
    end
    if self.Attachment0 then
        self.Attachment0:Destroy()
        self.Attachment0 = nil
    end
    if self.Attachment1 then
        self.Attachment1:Destroy()
        self.Attachment1 = nil
    end
    if self.TargetInfoUI then
        self.TargetInfoUI.Frame.Visible = false
    end
    lastHealth = nil
    self.LastAmmoValue = nil -- Reset the last ammo value when disabling
end

function ForceHitModule:Toggle()
    if self.ManuallyEnabled then
        self:Disable()
    else
        self:Enable()
    end
    return self.ManuallyEnabled
end

function ForceHitModule:IsEnabled()
    return self.ManuallyEnabled
end

function ForceHitModule:SetAutoTargetAll(value)
    self.AutoTargetAll = value
end

function ForceHitModule:GetAutoTargetAll()
    return self.AutoTargetAll
end

local function SetupUIMobileSupport()
    -- Crée ou ajuste l'UI
    if not ForceHitModule.ForceHitButton then
        ForceHitModule.CreateForceHitButton() -- Appelle la fonction existante pour créer le bouton
    end

    -- Ajuste la taille et la position du bouton en fonction du type d'appareil
    if ForceHitModule.ForceHitButton then
        local frame = ForceHitModule.ForceHitButton:FindFirstChild("Frame")
        if frame then
            local viewportSize = Camera.ViewportSize
            local buttonWidth, buttonHeight, buttonPosition

            if UserInputService.TouchEnabled then
                -- Ajustements pour mobile
                buttonWidth = math.min(100, viewportSize.X * 0.25)
                buttonHeight = math.min(50, viewportSize.Y * 0.1)
                buttonPosition = UDim2.new(0.5, -buttonWidth / 2, 0.8, -buttonHeight - 10)
            else
                -- Ajustements pour PC
                buttonWidth = math.min(120, viewportSize.X * 0.15)
                buttonHeight = math.min(60, viewportSize.Y * 0.08)
                buttonPosition = UDim2.new(0.5, -buttonWidth / 2, 0.9, -buttonHeight - 20)
            end

            frame.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
            frame.Position = buttonPosition
        end
    end

    -- Ajuste l'UI des informations sur la cible
    if ForceHitModule.TargetInfoUI then
        local uiFrame = ForceHitModule.TargetInfoUI.Frame
        local viewportSize = Camera.ViewportSize
        local uiWidth, uiHeight, uiPosition

        if UserInputService.TouchEnabled then
            -- Ajustements pour mobile
            uiWidth = math.min(200, viewportSize.X * 0.5)
            uiHeight = math.min(120, viewportSize.Y * 0.3)
            uiPosition = UDim2.new(0, 5, 0.5, -uiHeight / 2)
        else
            -- Ajustements pour PC
            uiWidth = math.min(300, viewportSize.X * 0.3)
            uiHeight = math.min(180, viewportSize.Y * 0.25)
            uiPosition = UDim2.new(0, 10, 0.5, -uiHeight / 2)
        end

        uiFrame.Size = UDim2.new(0, uiWidth, 0, uiHeight)
        uiFrame.Position = uiPosition
    end
end

function ForceHitModule:SetUIMobileSupport(value)
    self.UIMobileSupportEnabled = value
    if value then
        SetupUIMobileSupport() -- Appelle directement la fonction locale
    else
        if self.ForceHitButton then
            self.ForceHitButton:Destroy()
            self.ForceHitButton = nil
        end
    end
end

function ForceHitModule:SetWallCheckEnabled(value)
    self.WallCheckEnabled = value
end

function ForceHitModule:GetWallCheckEnabled()
    return self.WallCheckEnabled
end

function ForceHitModule:SetKillAll(value)
    self.KillAllEnabled = value
    if value then
        self.LastKillAllTime = 0
    end
end

function ForceHitModule:GetKillAll()
    return self.KillAllEnabled
end

function ForceHitModule:SetAutoStomp(value)
    self.AutoStompEnabled = value
end

function ForceHitModule:GetAutoStomp()
    return self.AutoStompEnabled
end

function ForceHitModule:SetTargetStrafe(value)
    self.TargetStrafeEnabled = value
    if value then
        -- Save the player's current position when enabling Target Strafe
        local localCharacter = LocalPlayer.Character
        local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
        if localRootPart then
            self.SavedPosition = localRootPart.CFrame
        end
        self.StrafeAngle = 0
    else
        -- Teleport the player back to the saved position when disabling Target Strafe
        if self.SavedPosition then
            local localCharacter = LocalPlayer.Character
            local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
            if localRootPart then
                localRootPart.CFrame = self.SavedPosition
            end
            self.SavedPosition = nil
        end
    end
end

function ForceHitModule:GetTargetStrafe()
    return self.TargetStrafeEnabled
end

function ForceHitModule:Cleanup()
    self:Disable()
    if self.ForceHitButton then
        self.ForceHitButton:Destroy()
        self.ForceHitButton = nil
    end
    if self.TargetInfoUI then
        self.TargetInfoUI.ScreenGui:Destroy()
        self.TargetInfoUI = nil
    end
    for _, connection in pairs(self.Connections) do
        connection:Disconnect()
    end
    self.Connections = {}
    if self.Highlight then
        self.Highlight:Destroy()
        self.Highlight = nil
    end
    if self.Tracer then
        self.Tracer:Destroy()
        self.Tracer = nil
    end
    if self.Attachment0 then
        self.Attachment0:Destroy()
        self.Attachment0 = nil
    end
    if self.Attachment1 then
        self.Attachment1:Destroy()
        self.Attachment1 = nil
    end
    if self.HitSound then
        self.HitSound:Destroy()
        self.HitSound = nil
    end
    if self.FOVCircleDrawing then
        self.FOVCircleDrawing.Parent:Destroy()
        self.FOVCircleDrawing = nil
    end
    self.SavedPosition = nil
    self.OriginalEnabledState = nil
    self.Whitelist = {}
    -- Ne pas réinitialiser FOVEnabled et FOVSize pour préserver l'état du toggle
end
getgenv().ForceHitModule = ForceHitModule
-- Initialisation des paramètres
if not getgenv().Rake then
    getgenv().Rake = {}
end
if not getgenv().Rake.Settings then
    getgenv().Rake.Settings = {}
end
if not getgenv().Rake.Settings.Misc then
    getgenv().Rake.Settings.Misc = {}
end
getgenv().Rake.Settings.Misc.TargetInfoEnabled = true
getgenv().Rake.Settings.Misc.UIMobileSupportEnabled = false

function ForceHitModule:SetDisableBlankShots(value)
    self.DisableBlankShots = value
    if not value then
        -- Forcer BlankShots à false si DisableBlankShots est désactivé (false)
        self.BlankShots = false
    end
end

function ForceHitModule:SetFOVEnabled(value)
    self.FOVEnabled = value
    if not value then
        self:Disable()
        if self.FOVCircleDrawing then
            self.FOVCircleDrawing.Visible = false
        end
    else
        if not self.FOVCircleDrawing then
            InitializeFOVCircle()
        end
        if self.FOVCircleDrawing then
            self.FOVCircleDrawing.Visible = true
        end
    end
    UpdateFOVCircle()
end

function ForceHitModule:GetFOVEnabled()
    return self.FOVEnabled
end

function ForceHitModule:SetFOVSize(value)
    self.FOVSize = math.clamp(value, 50, 500) -- Limiter la taille du FOV entre 50 et 500 pixels
end

function ForceHitModule:GetFOVSize()
    return self.FOVSize
end
return ForceHitModule
